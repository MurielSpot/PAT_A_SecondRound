# PAT甲级
## 字符串A1001(20).cpp
ac:1次,时长:20分钟左右,难度:1.

注意事项:
1. 下面第一个代码中,需特判0,因为0时,无法存入到字符串数组里,会什么都不输出.

思路:
1. 把数转成字符串,根据字符串中字符下标和逗号的关系加入逗号输出.
* 逆转数字顺序,存在\[1,n]里,倒着输出,%3等于0时,前面就应该加个逗号,但是第一个%3等于0不加.
* 不逆转数字顺序,存在\[0,n)里,利用n%3==(i+1)%3,即同余数的关系,将倒着数每隔3个字符的位置的后面加上一个逗号,最后一位后面不加逗号.

做题技巧:
1. 用string,里面有直接把数转为字符串的函数.string sum = to_string(a + b).
2. 求string字符串长度的函数s.length().

## 多项式加法A1002(25).cpp
ac:1次;时长:20分钟左右;难度:1.

注意事项:
1. 系数为0表名没有值.
2. 第二个多项式录入时可以直接加到第一个多项式里,不需要另外设数组.

其他:是加法,不是多项式乘法,差点按乘法做.另外总感觉多项式的题不容易做.

## 最短路径,dfs:A1003(25).cpp
有三种做法:
1. 只用dfs.这道题比较简单用这种方法即可.
2. 用dijkstra+dfs.复杂一点.
3. 指用dijkstra,可增加记录当前路径条数和汇集到的帮手的人数的数组,在每次找到最近结点之后对发现路径更近或路径相同帮手更多则对数组进行更新,思路比较复杂,不过也能做出来.(由于dijkstra经过n次循环之后,计算完了n个结点,到每个结点时,到这个结点的最大帮手数都是到这个结点时最优的,而与它相连的下一个结点肯定等于之前这个局部最优的最大值,加上下一个结点本身的帮手数,所以这种局部更新帮手数的方法不会出错.)

方法一:ac:1次,时长:31分钟,难度:2.
方法二:ac:1次,时长:20分钟左右,难度2.

注意事项:
1. 针对指用dfs的方法:
** 剪枝可以删,没有超时.
2. 针对第二种方法:
** 出了不少细节错误,比如把赋值等号=写成比较的等号==,最短路径找出新的最近结点时没有标记已访问vis[]=true,结果让输出最短路径条数和最大成员数,我输出成了最短路径经过的各个结点.
这些浪费了差不多十分钟时间调试.
** 最短路径中容易出错的地方:找最小dist时,要在未访问的结点中找,更新dist时,也是更新未访问结点的;找到dist最小的结点之后,应该标记已访问.
** vector不能用memset全部赋值为-1,我记得之前试过,赋值为全0不会异常退出,但是赋值为全-1,会异常退出.
